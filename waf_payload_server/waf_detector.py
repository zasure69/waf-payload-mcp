"""
WAF Detector
Fingerprints Web Application Firewalls by analyzing HTTP response headers and behavior.
"""

import logging
import re
from typing import Dict, List, Optional, Tuple

import requests
from requests.exceptions import RequestException

logger = logging.getLogger(__name__)

# WAF signatures: maps WAF name to detection patterns
WAF_SIGNATURES: Dict[str, Dict] = {
    "cloudflare": {
        "headers": {
            "server": ["cloudflare"],
            "cf-ray": [".*"],
            "cf-cache-status": [".*"],
        },
        "cookies": ["__cfduid", "__cf_bm", "cf_clearance"],
        "body_patterns": ["cloudflare", "attention required", "ray id"],
    },
    "akamai": {
        "headers": {
            "server": ["akamaighost", "akamai"],
            "x-akamai-transformed": [".*"],
            "akamai-grn": [".*"],
        },
        "cookies": ["akamai", "ak_bmsc", "bm_sv"],
        "body_patterns": ["access denied", "akamai", "reference.*#"],
    },
    "aws_waf": {
        "headers": {
            "x-amzn-requestid": [".*"],
            "x-amz-cf-id": [".*"],
            "x-amz-apigw-id": [".*"],
        },
        "cookies": ["awsalb", "awsalbcors"],
        "body_patterns": ["aws", "request blocked", "automated access"],
    },
    "modsecurity": {
        "headers": {
            "server": ["mod_security", "modsecurity", "owasp"],
        },
        "cookies": [],
        "body_patterns": [
            "mod_security",
            "modsecurity",
            "not acceptable",
            "owasp",
            "406 not acceptable",
        ],
    },
    "imperva": {
        "headers": {
            "x-iinfo": [".*"],
            "x-cdn": ["imperva", "incapsula"],
        },
        "cookies": ["visid_incap", "incap_ses", "_incapsula"],
        "body_patterns": ["incapsula", "imperva", "request unsuccessful"],
    },
    "sucuri": {
        "headers": {
            "server": ["sucuri"],
            "x-sucuri-id": [".*"],
            "x-sucuri-cache": [".*"],
        },
        "cookies": ["sucuri_cloudproxy"],
        "body_patterns": [
            "sucuri",
            "cloudproxy",
            "access denied",
            "sucuri website firewall",
        ],
    },
    "f5_bigip": {
        "headers": {
            "server": ["bigip", "big-ip", "f5"],
            "x-wa-info": [".*"],
        },
        "cookies": ["bigipserver", "ts", "f5_cspm"],
        "body_patterns": ["f5", "big-ip", "request rejected"],
    },
    "barracuda": {
        "headers": {
            "server": ["barracuda"],
        },
        "cookies": ["barra_counter_session", "BNI__BARRACUDA"],
        "body_patterns": ["barracuda", "request blocked"],
    },
    "fortinet": {
        "headers": {
            "server": ["fortiweb", "fortigate"],
        },
        "cookies": ["FORTIWAFSID", "cookiesession1"],
        "body_patterns": ["fortigate", "fortiweb", "fortinet", "fgd_icon"],
    },
    "wordfence": {
        "headers": {},
        "cookies": ["wfvt_", "wordfence"],
        "body_patterns": [
            "wordfence",
            "generated by wordfence",
            "your access to this site has been limited",
        ],
    },
    "comodo": {
        "headers": {
            "server": ["comodo"],
        },
        "cookies": [],
        "body_patterns": ["comodo", "protected by comodo"],
    },
    "citrix_netscaler": {
        "headers": {
            "via": ["ns-cache"],
            "cneonction": [".*"],
            "x-client-ip": [".*"],
        },
        "cookies": ["citrix_ns_id", "nsc_"],
        "body_patterns": ["netscaler", "ns-afd"],
    },
}

# Probe payloads designed to trigger WAFs
PROBE_PAYLOADS = [
    "<script>alert(1)</script>",
    "' OR 1=1--",
    "../../../etc/passwd",
    "${7*7}",
]


class WAFDetector:
    """Detects and fingerprints Web Application Firewalls."""

    def __init__(self, timeout: int = 10, verify_ssl: bool = True):
        self.timeout = timeout
        self.verify_ssl = verify_ssl
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": (
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                "AppleWebKit/537.36 (KHTML, like Gecko) "
                "Chrome/120.0.0.0 Safari/537.36"
            ),
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.5",
        })

    def detect(self, url: str) -> Dict:
        """
        Detect WAF on a target URL.

        Args:
            url: Target URL to probe

        Returns:
            Dict with detection results including WAF name,
            confidence, and evidence.
        """
        results = {
            "url": url,
            "waf_detected": False,
            "waf_name": None,
            "confidence": 0,
            "evidence": [],
            "all_detections": [],
        }

        try:
            # Step 1: Normal request — analyze headers and cookies
            normal_resp = self._safe_request("GET", url)
            if normal_resp:
                header_results = self._check_headers(normal_resp)
                cookie_results = self._check_cookies(normal_resp)
                results["all_detections"].extend(header_results)
                results["all_detections"].extend(cookie_results)

            # Step 2: Probe requests — trigger WAF with suspicious payloads
            for probe_payload in PROBE_PAYLOADS[:2]:  # Limit probes for speed
                probe_url = self._build_probe_url(url, probe_payload)
                probe_resp = self._safe_request("GET", probe_url)
                if probe_resp:
                    # Check if blocked (403, 406, 429, etc.)
                    if probe_resp.status_code in (403, 406, 429, 451, 503):
                        results["all_detections"].append({
                            "waf": "generic",
                            "evidence": f"Blocked with status {probe_resp.status_code} for probe payload",
                            "confidence": 30,
                        })

                    # Check response body for WAF signatures
                    body_results = self._check_body(probe_resp)
                    results["all_detections"].extend(body_results)

                    # Check probe response headers too
                    header_results = self._check_headers(probe_resp)
                    results["all_detections"].extend(header_results)

        except Exception as e:
            results["error"] = str(e)
            return results

        # Aggregate results
        if results["all_detections"]:
            # Score each WAF by summing confidence
            waf_scores: Dict[str, int] = {}
            waf_evidence: Dict[str, List[str]] = {}
            for det in results["all_detections"]:
                waf = det["waf"]
                waf_scores[waf] = waf_scores.get(waf, 0) + det["confidence"]
                if waf not in waf_evidence:
                    waf_evidence[waf] = []
                waf_evidence[waf].append(det["evidence"])

            if waf_scores:
                # Pick highest scored WAF (ignore "generic")
                named_scores = {k: v for k, v in waf_scores.items() if k != "generic"}
                if named_scores:
                    best_waf = max(named_scores, key=named_scores.get)
                    results["waf_detected"] = True
                    results["waf_name"] = best_waf
                    results["confidence"] = min(named_scores[best_waf], 100)
                    results["evidence"] = waf_evidence[best_waf]
                elif "generic" in waf_scores:
                    results["waf_detected"] = True
                    results["waf_name"] = "unknown_waf"
                    results["confidence"] = min(waf_scores["generic"], 100)
                    results["evidence"] = waf_evidence["generic"]

        return results

    def _safe_request(self, method: str, url: str) -> Optional[requests.Response]:
        """Make a request with error handling."""
        try:
            resp = self.session.request(
                method, url,
                timeout=self.timeout,
                verify=self.verify_ssl,
                allow_redirects=True,
            )
            return resp
        except RequestException as e:
            logger.debug(f"Request failed for {url}: {e}")
            return None

    def _build_probe_url(self, base_url: str, payload: str) -> str:
        """Build a URL with probe payload as a query parameter."""
        separator = "&" if "?" in base_url else "?"
        encoded = requests.utils.quote(payload)
        return f"{base_url}{separator}waftest={encoded}"

    def _check_headers(self, resp: requests.Response) -> List[Dict]:
        """Check response headers against WAF signatures."""
        detections = []
        headers_lower = {k.lower(): v for k, v in resp.headers.items()}

        for waf_name, sig in WAF_SIGNATURES.items():
            for header_name, patterns in sig.get("headers", {}).items():
                header_val = headers_lower.get(header_name, "")
                if header_val:
                    for pattern in patterns:
                        if re.search(pattern, header_val, re.IGNORECASE):
                            detections.append({
                                "waf": waf_name,
                                "evidence": f"Header '{header_name}: {header_val}'",
                                "confidence": 40,
                            })
                            break

        return detections

    def _check_cookies(self, resp: requests.Response) -> List[Dict]:
        """Check response cookies against WAF signatures."""
        detections = []
        cookie_names = [c.name.lower() for c in resp.cookies]
        cookie_str = " ".join(cookie_names)

        for waf_name, sig in WAF_SIGNATURES.items():
            for cookie_pattern in sig.get("cookies", []):
                if any(cookie_pattern.lower() in cn for cn in cookie_names):
                    detections.append({
                        "waf": waf_name,
                        "evidence": f"Cookie matching '{cookie_pattern}'",
                        "confidence": 35,
                    })

        return detections

    def _check_body(self, resp: requests.Response) -> List[Dict]:
        """Check response body against WAF signatures."""
        detections = []
        body_lower = resp.text[:5000].lower()  # Check first 5KB only

        for waf_name, sig in WAF_SIGNATURES.items():
            for pattern in sig.get("body_patterns", []):
                if re.search(pattern, body_lower, re.IGNORECASE):
                    detections.append({
                        "waf": waf_name,
                        "evidence": f"Body contains pattern '{pattern}'",
                        "confidence": 30,
                    })
                    break  # One body match per WAF is enough

        return detections

    @staticmethod
    def get_bypass_techniques(waf_name: str) -> Dict:
        """
        Get recommended bypass techniques for a specific WAF.

        Args:
            waf_name: WAF name (e.g., 'cloudflare', 'akamai')

        Returns:
            Dict with bypass techniques and tips
        """
        techniques = {
            "cloudflare": {
                "waf": "Cloudflare",
                "general_tips": [
                    "Cloudflare primarily uses regex-based pattern matching",
                    "Focus on encoding, case variation, and comment injection",
                    "Cloudflare updates rules frequently — try recent bypasses from Twitter/GitHub",
                    "Try chunked transfer encoding for POST requests",
                ],
                "xss_bypasses": [
                    "Use SVG/animate/set tags instead of script tags",
                    "Template literals instead of parentheses: alert`1`",
                    "Bracket notation: window['al'+'ert'](1)",
                    "HTML entities in href: javascript&colon;alert(1)",
                    "DOM clobbering techniques",
                ],
                "sqli_bypasses": [
                    "Newline between keywords: UNION%0ASELECT",
                    "Hash comment with newline: #foo%0AUNION SELECT",
                    "Scientific notation: 1e0UNION SELECT",
                    "/*!50000UNION*/ /*!50000SELECT*/",
                ],
                "encoding_tips": [
                    "Double URL encoding often works",
                    "Unicode fullwidth characters",
                    "Mix of URL encoding and unencoded chars",
                ],
            },
            "akamai": {
                "waf": "Akamai (Kona Site Defender)",
                "general_tips": [
                    "Akamai uses behavioral analysis + pattern matching",
                    "Rate limiting may trigger before payload testing",
                    "Try varying request timing and headers",
                    "HTTP/2 specific bypasses sometimes work",
                ],
                "xss_bypasses": [
                    "Less common event handlers: onpointerover, ontouchstart",
                    "SVG animate/set elements",
                    "JavaScript template literals",
                    "MathML namespace confusion",
                ],
                "sqli_bypasses": [
                    "Whitespace alternatives: %09, %0b, %0c",
                    "Inline comments between keywords",
                    "Hex-encoded strings",
                    "Alternative to UNION: stacked queries where possible",
                ],
                "encoding_tips": [
                    "UTF-8 overlong encoding",
                    "Mix of encoding types in single payload",
                    "Chunk request body in POST requests",
                ],
            },
            "aws_waf": {
                "waf": "AWS WAF",
                "general_tips": [
                    "AWS WAF rules are configurable — coverage varies per deployment",
                    "Core Rule Set (CRS) may or may not be enabled",
                    "Test with both GET and POST methods",
                    "Header injection may bypass body-only rules",
                ],
                "xss_bypasses": [
                    "Less common tags: details/ontoggle, marquee/onstart",
                    "Anchor tags with javascript protocol",
                    "SVG with animate/set elements",
                    "Iframe srcdoc injection",
                ],
                "sqli_bypasses": [
                    "Comment injection: SEL/**/ECT",
                    "HAVING-based errors",
                    "EXTRACTVALUE/UPDATEXML for error-based",
                    "Boolean blind with LIKE instead of =",
                ],
                "encoding_tips": [
                    "Double URL encoding",
                    "Unicode normalization tricks",
                    "JSON body with encoded payloads",
                ],
            },
            "modsecurity": {
                "waf": "ModSecurity (OWASP CRS)",
                "general_tips": [
                    "CRS paranoia level determines strictness (1-4)",
                    "Lower paranoia levels have more bypass opportunities",
                    "ModSecurity is open-source — study the rules directly",
                    "Rule exclusions may create gaps",
                ],
                "xss_bypasses": [
                    "Case alternation: <ScRiPt>",
                    "Null bytes before tags: <%00script>",
                    "Less common event handlers",
                    "Mathematical markup: <math><mtext>",
                ],
                "sqli_bypasses": [
                    "MySQL version comments: /*!50000SELECT*/",
                    "Mixed case: UnIoN SeLeCt",
                    "Tab/newline whitespace: UNION%09SELECT",
                    "IN operator instead of = for auth bypass",
                ],
                "encoding_tips": [
                    "Backslash path traversal instead of forward slash",
                    "Null byte injection (older PHP versions)",
                    "URL-encoded dots for path traversal",
                ],
            },
            "imperva": {
                "waf": "Imperva (Incapsula)",
                "general_tips": [
                    "Imperva combines signature + behavioral analysis",
                    "Rotating IPs and user agents can help avoid behavioral blocks",
                    "Try different HTTP methods (PUT, PATCH)",
                    "Content-Type manipulation sometimes bypasses",
                ],
                "xss_bypasses": [
                    "MathML namespace confusion",
                    "SVG animate with complex attribute values",
                    "JavaScript protocol with encoding",
                    "DOM-based payloads that don't appear in server response",
                ],
                "sqli_bypasses": [
                    "Complex subquery nesting",
                    "Alternative functions: MID() vs SUBSTR()",
                    "Hex-encoded table/column names",
                    "Conditional comments with version numbers",
                ],
                "encoding_tips": [
                    "Unicode fullwidth characters",
                    "IPv6 mapped addresses for SSRF",
                    "Double encoding with mixed types",
                ],
            },
            "sucuri": {
                "waf": "Sucuri CloudProxy",
                "general_tips": [
                    "Try to find the origin IP to bypass entirely",
                    "Sucuri may cache pages — try cache-busting params",
                    "POST body may have different rules than URL params",
                ],
                "xss_bypasses": [
                    "Less common SVG elements",
                    "Custom element event handlers",
                    "Template literal syntax",
                ],
                "sqli_bypasses": [
                    "Inline comment splitting",
                    "Alternative whitespace characters",
                    "Hex-encoded strings",
                ],
                "encoding_tips": [
                    "URL encoding of dots and slashes for LFI",
                    "Unicode variants of common characters",
                ],
            },
            "f5_bigip": {
                "waf": "F5 BIG-IP ASM",
                "general_tips": [
                    "F5 ASM learns application behavior over time",
                    "New parameters may not be covered by learned policy",
                    "Try parameter pollution (HPP)",
                    "Evasion techniques targeting the learning mode",
                ],
                "xss_bypasses": [
                    "Null byte injection before tags",
                    "Tab/newline inside tag attributes",
                    "JavaScript protocol variants",
                ],
                "sqli_bypasses": [
                    "Scientific notation in numeric contexts",
                    "Custom function aliasing",
                    "Nested subqueries to confuse parser",
                ],
                "encoding_tips": [
                    "Chunk transfer encoding",
                    "Multipart form data encoding",
                ],
            },
        }

        waf_key = waf_name.lower().replace(" ", "_").replace("-", "_")

        # Exact match
        if waf_key in techniques:
            return techniques[waf_key]

        # Partial match
        for key, value in techniques.items():
            if waf_key in key or key in waf_key:
                return value

        # Unknown WAF — return general advice
        return {
            "waf": waf_name,
            "general_tips": [
                "WAF not in database — try generic bypass techniques",
                "Start with encoding-based bypasses (URL, HTML entity, Unicode)",
                "Try alternative HTTP methods (PUT, PATCH, DELETE)",
                "Test for differences between GET parameters and POST body filtering",
                "Use chunked transfer encoding",
                "Try IP rotation and user agent spoofing",
                "Look for the original server IP to bypass CDN/WAF entirely",
            ],
            "xss_bypasses": [
                "Try less common HTML tags and event handlers",
                "Use JavaScript template literals instead of parentheses",
                "SVG/MathML namespace confusion",
            ],
            "sqli_bypasses": [
                "Comment injection between keywords",
                "Alternative whitespace (tab, newline)",
                "Case variation",
            ],
            "encoding_tips": [
                "Double URL encoding",
                "Unicode fullwidth characters",
                "HTML entity encoding",
            ],
        }
